(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{112:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return p}));var a=t(0),o=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=o.a.createContext({}),d=function(e){var n=o.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=d(e.components);return o.a.createElement(i.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},b=o.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),u=d(t),b=a,p=u["".concat(s,".").concat(b)]||u[b]||m[b]||r;return t?o.a.createElement(p,l(l({ref:n},i),{},{components:t})):o.a.createElement(p,l({ref:n},i))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,s=new Array(r);s[0]=b;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var i=2;i<r;i++)s[i]=t[i];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},80:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return d}));var a=t(3),o=t(7),r=(t(0),t(112)),s={id:"resolving-domain-name",title:"Resolving Names"},l={unversionedId:"resolving-domain-name",id:"resolving-domain-name",isDocsHomePage:!1,title:"Resolving Names",description:"---",source:"@site/docs/resolving-domain-name.md",slug:"/resolving-domain-name",permalink:"/docs/resolving-domain-name",editUrl:"https://github.com/trustdomains/documentation/master/docs/resolving-domain-name.md",version:"current",sidebar:"someSidebar",previous:{title:"Namehash",permalink:"/docs/namehash"},next:{title:"Deployed Contract",permalink:"/docs/deployed-contract"}},c=[{value:"Resolving cryptocurrency addresses",id:"resolving-cryptocurrency-addresses",children:[]},{value:"Resolving IPFS",id:"resolving-ipfs",children:[]},{value:"Resolving Social Information",id:"resolving-social-information",children:[]}],i={rightToc:c};function d(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},i,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("hr",null),Object(r.b)("p",null,"Resolving a domain name is process of retrieving a domain's records what saved in the domains. And there is no more other permission for user to access the records from the domain, All the records are public to everyone."),Object(r.b)("p",null,"Resolver has a list of key-value data structure to store the records. The key and value are string in solidity, and the data didn't self-authentication format infomation, so you should validate the data format before saving and after retrieving."),Object(r.b)("p",null,"Trust Domains supports many types of records:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Cryptocurrency addresses"),Object(r.b)("li",{parentName:"ul"},"IPFS CID"),Object(r.b)("li",{parentName:"ul"},"Metadata"),Object(r.b)("li",{parentName:"ul"},"Social Media")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"More type of records will coming soon!")),Object(r.b)("h2",{id:"resolving-cryptocurrency-addresses"},"Resolving cryptocurrency addresses"),Object(r.b)("p",null,"To resolve a cryptocurrency address, you just supply both the domain namehash and cryptocurrency key of the cryptocurrency whose address you want to resolve. For example:"),Object(r.b)("p",null,"Cryptocurrency keys:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Bitcoin - wallet.BTC.address"),Object(r.b)("li",{parentName:"ul"},"Ethereum - wallet.ETH.address"),Object(r.b)("li",{parentName:"ul"},"Conflux - wallet.CFX.address"),Object(r.b)("li",{parentName:"ul"},"Zcash - wallet.ZEC.address"),Object(r.b)("li",{parentName:"ul"},"Neo - wallet.neo.address"),Object(r.b)("li",{parentName:"ul"},"Binance Smart Chain - wallet.bnb.address"),Object(r.b)("li",{parentName:"ul"},"HecoChain - wallet.bnb.address"),Object(r.b)("li",{parentName:"ul"},"OKExChain - wallet.okt.address")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const tns = new TrustNameService()\nconst domain = 'token.cfx'\nconst tokenId = namehash(domain)\n\nconst btc = await tns.address(tokenId, 'wallet.BTC.address')\nconsole.log(btc)\n// 1GX28yLjVWux7ws4UQ9FB4MnLH4UKTPK2z\n\nconst eth = await tns.address(tokenId, 'wallet.ETH.address')\nconsole.log(eth)\n// 0x0efdcc214acfdda3603c4e0e6e567bb1b34569c1\n\nconst cfx = await tns.address(tokenId, 'wallet.CFX.address')\nconsole.log(cfx)\n// cfx:aaks65zn43jf4jwffcy0fyadspzh9uszpy9jdyhwdj\n\nconst zec = await tns.address(tokenId, 'wallet.ZEC.address')\nconsole.log(zec)\n// t1bEGpCsvYenFdw3YqSFJazJBefNGnY5TK3\n")),Object(r.b)("h2",{id:"resolving-ipfs"},"Resolving IPFS"),Object(r.b)("p",null,"To resolve a IPFS CID, you just supply both the domain namehash and IPFS key of the domain whose IPFS hash you want to resolve. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const tns = new TrustNameService()\nconst domain = 'token.cfx'\nconst tokenId = namehash(domain)\n\nconst ipfsHash = await tns.get(tokenId, 'ipfs.value')\nconsole.log(ipfsHash)\n// QmXnqs44mWCA9xid6wRH1v2G9JFvRisiBVPi5zKHsRZd2h\n")),Object(r.b)("h2",{id:"resolving-social-information"},"Resolving Social Information"),Object(r.b)("p",null,"To resolve the social media information bind on the domains, you can pass a the social keys and the token id, you will get the social informations."),Object(r.b)("p",null,"Social keys:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Twitter - social.twitter"),Object(r.b)("li",{parentName:"ul"},"Telegram - social.telegram"),Object(r.b)("li",{parentName:"ul"},"Blog - social.blog"),Object(r.b)("li",{parentName:"ul"},"Email - social.email")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const tns = new TrustNameService()\nconst domain = 'token.cfx'\nconst tokenId = namehash(domain)\n\nconst twitter = await tns.get(tokenId, 'social.twitter')\nconsole.log(twitter)\n// https://twitter.com/trust_domains\n\nconst telegram = await tns.get(tokenId, 'social.telegram')\nconsole.log(telegram)\n// https://t.me/trustdomains\n\nconst blog = await tns.get(tokenId, 'social.blog')\nconsole.log(blog)\n// https://trustdomains.medium.com\n\nconst email = await tns.get(tokenId, 'social.email')\nconsole.log(email)\n// contract@trustdomains.org\n")))}d.isMDXComponent=!0}}]);